\chapter{Overview of techniques}
This chapter introduces the techniques used to simulate destructible environments. First, we will talk about the development of the destructible environment in several games and game engines, and then about general approaches to this problem.

We will repeatedly categorise the content of the game world in following way: We will use the word object to refer to any building, crate, door, tree or other items that occur in the game environment, but excluding terrain, distant environment like skyboxes and any in-game characters. Most of the modern 3D games use the term destructible environment as a reference to destructible objects because they do not support the destruction of terrain. We will comply with this terminology and if not specified otherwise use destructible environment as a reference to a destruction of objects and not the terrain.

\section{Implementations in mainstream gaming}
\label{sec:common}
In this brief overview, we will introduce most common approaches to environment destruction that can be seen through the games released in last 40 years. More common approaches can be regularly seen in newly released games. 

\para{Object replacement or removal} was the first method used to simulate a destructible environment in a computer game, mostly because it is straightforward and undemanding. Despite its simplicity, it can still produce a very desirable result. In fact, it is still most widely used approach to a destructible environment in computer games. This approach is based on swapping models for more damaged ones or completely removing them. Because it relies on pre-made models, exact collision points on the models are not considered, and the result is always the same.

In 2D setting, we will not differentiate between objects and terrain and refer to both as the environment.
First, 2D games featuring the destructible environment are arcade games like the \emph{Space Invaders (1978)}~\footnote{https://en.wikipedia.org/wiki/Space\_Invaders} where the environment is represented by cells in a grid. After taking damage, the texture of the cell is replaced by another one and the finally completely removed. A few years later, new environment destruction technique was introduced in games like  \emph{Scorched Earth (1991)}~\footnote{https://en.wikipedia.org/wiki/Scorched\_Earth\_(video\_game)} and \emph{Worms (1995)}~\footnote{https://www.team17.com/games/worms-original}. Collision and removal of terrain in those games is based on individual pixels rather than whole objects, which creates a more realistic visual effect.

The most common implementation of destructible objects in 3D games has not changed much over the years. Every object that the player can modify has a set of more damaged models prepared. Based on how much damage is applied, the models are swapped and eventually completely removed, as seen in \cref{fig:doors}. It is usually accompanied by animations, debris and dust generation to make the process look realistic. The downfall of this method is the necessity to replace the whole in-game object. There has to be a significant number of objects pre-made for different scenarios to make the game look realistic and it has little flexibility to react to specific player actions. As an example, in the \emph{Source} engine, the hole in the door (\cref{fig:doors}) is always in the same place, regardless of the point of impact, another example can be the \emph{Duke Nukem 3D}~\footnote{https://en.wikipedia.org/wiki/Duke\_Nukem\_3D}. In this game, specific parts of the walls are created as separate objects that disappear when hit.

\begin{figure} 
\centering
\includegraphics[width=\textwidth]{img/doors}
\caption{\emph{Source} engine swaps door models. Image taken from \emph{Counter Strike: Global Offensive}. Successively damaging any doors in the game will always produce this sequence of models, regardless of the exact point where the damage is applied.}
\label{fig:doors}
\end{figure}

\para{Height map} approach is closely intertwined with terrain generation. The basic principle behind modifying the environment with this method is changing the parameters for terrain generation and repetitive generation of affected parts of the terrain. We can find this method used in the first 3D games featuring destructible terrain, \eg \emph{Magic carpet (1994)}~\footnote{https://ultimatehistoryvideogames.jimdo.com/magic-carpet} or \emph{Starfighter 3000 (1994)}~\footnote{https://en.wikipedia.org/wiki/Star\_Fighter\_(video\_game)}.

The height map for 3D terrain is represented as a 2D grid. If we use the grid $G$ as a base of 3D space, each cell $C(x,y)$ represents the height $z$ of the respective column. Most common approach is to use 2D grey-scale bitmap and represent the height as a colour distance between white and black. Because the grid only contains information about the discrete points, interpolation is used to create continuous terrain. We can also see this method as creating a function $F(x,y) \rightarrow z$ where $\forall (x,y) \in G : F(x,y) = C(x,y)$. From this point of view, it is obvious that terrain generated and modified with this approach can only change the height and does not allow for creating tunnels and similar shapes.

\para{\emph{Geo-Mod}} (\emph{Geometry Modification Technology}\cite{geomod}) is an engine developed for the \emph{Red Faction (2001)}\footnote{http://redfaction.wikia.com/wiki/Red\_Faction} video game. It allows players to modify and make holes in the terrain using the solution of creating objects representing an empty space. The difference of meshes is calculated in real time to represent the terrain with a hole. Even though the engine does not work well with the buildings and other objects, it represents the first significant attempt to create the fully destructible 3D environment in real time constraints.

\para{\emph{Geo-Mod 2}}~\cite{geomod}\footnote{Geo-Mod 2.0 presentation video https://www.youtube.com/watch?v=lICurOVsNv0} does not feature destructible terrain, instead, it uses physics simulation on specially prepared objects. A set of smaller objects is used as a ragdoll for the stress-based simulation model. The complexity of simulation limits the engine in the scale of the game world and mutual proximity of destructible objects.


\para{\emph{Frostbite}}~\footnote{http://www.frostbite.com/about/frostbite-3} engine and mainly it's component \emph{Destruction}~\cite{destruction} is currently used in the most titles featuring destructible environment \eg \emph{Battlefield} series or \emph{Star Wars Battlefront (2015)}. It supports the dynamic micro-destruction on the surface and the large scale predetermined destruction on whole buildings. For the large-scale destruction, the buildings are created from smaller parts linked together. Each part can disappear on its own (\cref{fig:frostbite}), and when there is not enough left, the whole building collapses. It does not use internal body stress or any physics while doing this simulation. \emph{Frostbite} is a proprietary engine and there is no public information on the implementation of micro-destruction.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/frostbite}
\caption{The leftmost image shows the arrangement of destructible elements for the large-scale destruction in \emph{Frostbite} engine. The rest shows the process of large-scale destruction in \emph{Battlefield: Bad Company} implemented using \emph{Frostbite 1}.}
\label{fig:frostbite}
\end{figure}

\section{Methods and algorithms}

Here we will give a short overview of several more rigorous methods commonly used for simulations of destructible environment. 

In simulations, we consider two types of objects: soft bodies and rigid bodies. The rigid body represents an object with a constant shape and is not deformable. On the other hand, soft bodies are deformable under an applied force. There are no rigid objects in the real world. However, soft body simulation is computationally more expensive than the rigid body. Therefore, in the computer games, rigid body simulation is used almost exclusively. This brings us back to our problem, imitation of soft body behaviour on rigid bodies in the real-time simulation. It is worth mentioning that many soft bodies in the games players can not directly interact with, \eg waving flag or flowing water, are implemented as a pre-rendered animations and not actual simulations.

\subsection{Soft body deformation}
In this section, we will shortly introduce two different approaches for simulation of soft bodies. Despite the fact that soft bodies are currently not used in computer games to an extend of destructible environment, a few soft body objects can show up in a game. We also expect that with an evolution of more powerful hardware, soft body deformation will make its way into gaming world in the near future.
\label{sec:softBody}

\para{Finite Element Method} (FEM) is a numerical method used to simulate the behaviour of a system that can be modelled by solving the same problem for the smaller discrete parts, called finite elements. Each element calculates its physics states, \eg stress or temperature, and propagates the results to neighbouring elements. This model allows for simulation of fluid dynamics, brittle fractures~\cite{brittlefracture}, ductility~\cite{ductilefracture}, elasticity, heat transfer and other physical properties. It is beneficial in engineering, modelling and rendering scenes for computer generated images. FEM requires a lot of computational resources and therefore until recently it was not possible to implement it in real-time environment of a computer game. Now with more processing power and optimised algorithms especially developed for real-time animation, like the one O'Brien~\cite{femingames} describes this method can make its way into modern games.

\para{Material point method} (MPM) is used to simulate the behaviour of continuum materials (continuous mass not discrete particles). MPM is a meshfree and Arbitrary Lagrangian–Eulerian numerical method \cite{ALE}. The Lagrangian element, or a material point, is the primary representation possessing position, velocity and deformation gradient. A simplified overview of algorithm steps follows, for more details see the thesis of \citet{jiang2015material}.

\begin{enumerate}
    \item Grid data are reinitialized to default values.
    \item Weights and weight gradients are computed on every particle.
    \item Mass and momentum are transferred from the particles to the grid.
    \item The explicit forces on nodes are calculated
    \item The explicit nodal velocity update is performed
    \item Grid based collision is performed on vertices.
    \item Particles are updated from grid velocities.
\end{enumerate}
The steps are illustrated in \cref{fig:mpm}.

MPM is useful for both fluid and soft body dynamics. It can simulate deformation, fractures, heat transfer, melting and other changes of material properties. 

As a popular example of MPM we can take a look at snow simulation in the \emph{Disney} film \emph{Frozen (2013)}. The simulation software \emph{Matterhorn}~\footnote{https://www.disneyanimation.com/technology/innovations/matterhorn} can simulate the behaviour of different types of snow (\eg wet, fresh, sticky) and other materials, such as sand or mud.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/MPM}
\caption{Material point method algorithm overview. The top and the bottom rows operate in particle domain (Lagrangian) while the middle depicts grid-based (Eulerian) operations \cite{disney}.
}
\label{fig:mpm}
\end{figure}

\subsection{Rigid body decomposition}
Unlike in the soft bodies, in rigid bodies, we can not introduce deformation and the following fracture when the deformation limit is exceeded. To handle this problem, there are numerous approaches of decomposing the rigid body in the way that imitates fractures achieved by exceeding the elasticity of the material. The most common method used today is Voronoi tessellation.

There are also other solutions for decomposition, \eg slicing by planes or convex decomposition, but Voronoi cells are considered to look better and more natural than other methods. 

\para{Voronoi tessellation} is a method of decomposing an object into a smaller parts, as shown on \cref{fig:voro}. It is also applicable for \eg terrain generation~\cite{voronoiterrainrealtime}, but we will focus on object decomposition. Assuming the input is a closed triangular mesh with non-empty volume, the tessellation can be done in following three steps:

\begin{figure}
        \centering
        \includegraphics[width=0.4\textwidth]{img/clipped}
        \caption{The result of Voronoi tessellation \cite{yan2010efficient}}
        \label{fig:voro}
\end{figure}

\begin{description}
    \item[Delaunay tetrahedral decomposition] Given points $P$ in general position (the vertices of input mesh and a set of points inside its volume), tetrahedral mesh $DT(P)$ can be generated satisfying the following condition: no point in $P$ is inside the circumscribed sphere of any tetrahedra in $DT(P)$.
    \item[Creating Voronoi diagram] For a Delaunay tetrahedral decomposition, its dual graph (with vertices in the centre of tetrahedrons circumscribed sphere) is a Voronoi diagram (see \cref{fig:voro}.
    
 \begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{img/delaunay}
    \includegraphics[width=0.4\textwidth]{img/voronoi}
    \caption{Transformation of 2D Delaunay triangulation to Voronoi diagram. Source: \url{https://en.wikipedia.org/wiki/Delaunay\_triangulation}}
    \label{fig:DT}
\end{figure}

    \item[Clipping the Voronoi diagram] Boundary cells of the Voronoi diagram are infinite (see \cref{fig:DT}) and need to be clipped by the original input triangular mesh. The efficient algorithm proposed by~\citet{yan2010efficient} for this task finds the intersection of the boundary Voronoi cell with the triangular mesh and continues with neighbourhood propagation to determine all intersections. 
\end{description}

\section{Related research}
With releases of the new games we can see constant progress in the domain of destructible environment. Unfortunately we do not have access the to most efficient algorithms developed by the game studios. In this section we will describe two scientific papers proposing different techniques for environment destruction in computer games. 

\subsection{A fast method for simulating destruction and the generated dust
and debris}
\label{sec:edem}
This method \cite{edem} approaches destruction on three scales. At first, the destruction is performed on a coarse scale, and then the applied energy is used to calculate the amount and size of smaller debris and finally dust particles.

\begin{description}
\item[Destruction on a coarse scale] on this level we use Extended Distinct Element Method (EDEM) which is based on Element Method described in section \ref{sec:softBody}. The behaviour of the entire system is calculated based on interactions of individual elements. EDEM extends the method formerly using only contact force by adding pore springs connecting the adjacent elements. If we imagine the elements as individual bricks, then the pore springs represent a mortar holding them together. If the applied force is sufficient and elements move apart far enough, the fraction takes place. Pore springs also help the object retain its original shape after applied force.
\begin{figure}[ht!]
        \centering
        \includegraphics[width=0.7\textwidth]{img/spring}
        \caption{The force between two EDEM elements \cite{edem}}
        \label{spring}
\end{figure}
\\Algorithm for creating EDEM elements
\begin{enumerate}
\item Represent the original object as a closed surface model.
\item Arbitrarily arrange the EDEM elements inside the object.
The elements are allowed to overlap at this point.
\item Move the elements by performing the EDEM simulation. However, we only consider the contact force in this simulation.
\item Perform collision detection between the object’s surface
and the elements, making sure that the elements always
stay inside the object.
\item Repeat (3)–(4) until the elements are stabilised.
\item Construct a Delaunay diagram from the set of elements
and put the pore springs on the Delaunay edges that connect
the elements
\end{enumerate}
The position $\mathbf{x}_I$ and velocity $\mathbf{v}_I$ of the element $\mathit{I}$ can be found using Newton’s equation of motion as follows:
 
\[M\frac{d\mathbf{v}_I}{dt} = \sum_{J \in contact}^{} \mathbf{F}_{JI}^c + \sum_{K \in pore}^{} \mathbf{F}_{KI}^p + M\mathbf{g} \]
\[ \frac{d\mathbf{x}_I}{dt} = \mathbf{v}_I \]
Here, $\mathbf{g}$ is the gravitational vector, $\mathbf{F}^c_{JI}$ is the contact force, $\mathbf{F}^p_{KI}$ is the force due to the pore springs and $\mathit{M}$ is the element’s mass. Contact contains elements \{I, J\} if they are closer than the diameter of a single element, while pore
contains a pair of elements \{I, K\} when they are connected by a pore spring.

\item[Fine debris generation and simulation] After fracture between EDEM elements we can determine if the energy was big enough to break EDEM element into smaller debris. The Gaudin-Schuhmann distribution is used to determine the size of debris. Debris is taken out of EDEM simulation and put into particle simulation, where each piece is represented as a particle without volume.

\item[Dust generation and simulation] Amount of generated dust is based on fracture energy and results of debris generation. Instead of simulating particles smaller than predetermined margin, they are represented as dust in a grid-based fluid simulation. The density of particular cell represents the amount of dust.

\end{description}

 \begin{figure}
        \centering
        \includegraphics[width=0.49\textwidth]{img/edem_real}
        \includegraphics[width=0.49\textwidth]{img/edem}
        \caption{Result of this method with generated dust and debris (left) and EDEM elements (right) \cite{edem}}
        \label{fig:edem}
    \end{figure}
   
\begin{table}[ht!]
    \begin{center}
  \begin{tabular}{ |l|c|c|c|c|c| } 
  \hline
  EDEM elements & 128 & 256 & 512 & 1024 & 2048 \\ 
  \hline
  FPS & 320 & 160 & 75 & 30 & 9.1 \\ 
  \hline
  
  \end{tabular}
  \end{center}
  \caption{Performance of EDEM element method without rendering \cite{edem}}
  \label{table1}
\end{table}
In conclusion, based on table \ref{table1}, the frames per second (fps) drop proportionally with growing number of EDEM elements. That makes this approach unusable in large scale environments in real time game which demands constant 30fps at least.

\subsection{Real Time Dynamic Fracture
with Volumetric Approximate Convex Decompositions}
Now we will represent a short overview of this method, for the details please see~\citet{nvidia}.
This approach does not try to simulate the internal forces of an object and focuses only on rigid body decomposition. The idea behind this method is to represent the mesh as a compound shape of convex parts. The algorithm used for convex decomposition is Volumetric Approximate Convex Decomposition (VACD), it works by introducing the Voronoi decomposition into the bounding box of a mesh and then clipping the mesh against Voronoi cells. The fracture pattern is precomputed and represented as a set of convex cells. The algorithm works as followed (\cref{fig:vacdalg}:
\begin{enumerate}
\item The fracture pattern is aligned with the point of impact. The fracture pattern can be arbitrary rotated or scaled, to avoid repetitive patterns.
\item The intersections of all cells with all convexes are computed.  To compute the intersection of a single cell with a single convex, the convex is clipped against all the planes of the cell one by one. 
At the end of this step, we have a set of new convexes, and each convex belongs to exactly one cell.
\item If there are pieces that entirely fill one cell, we can weld them back together as one convex piece. To test whether it can be done, the volume of the cell and the sum of pieces.
\item Next, all the convexes belonging to one cell are combined to form a new compound. This ensures that the decomposition into compound shape is not visible after fracture (see \cref{fig:vacdfracture}).
\begin{figure}
        \centering
        \includegraphics[width=0.7\textwidth]{img/vacdfracture}
        \caption{The decomposition of the
initial compound mesh does not become visible when a fracture
patterns is applied. Source: \citet{nvidia}}
        \label{fig:vacdfracture}
\end{figure}
\item At last, the separate islands of convex parts need to be detected and individual compound shapes constructed for them.
\end{enumerate}

\begin{figure}
\centering
        \includegraphics[width=\textwidth]{img/vacdAlgorithm}
        \caption{Overview of the fracture algorithm. Left: The fracture pattern (red) is aligned with the impact location (black dot). Middle: All
convex pieces are intersected with all cells. The green convex pieces can be welded to form a single piece because they cover the entire
cell. Pieces within one cell become a new compound (colouring). Island detection finds that the dark red compound needs to be split. Source: \citet{nvidia}}
        \label{fig:vacdalg}
\end{figure}

The cost of fracturing in this method is dependent only on the size of the object being fractured. The paper suggests that the model consisting of million vertices and five-hundred thousand faces can be fractured under 50ms. This makes this method suitable for real-time computer games.






