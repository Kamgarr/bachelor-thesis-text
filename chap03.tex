\chapter{Implementation Design}
\label{chaptImplementation}
In this chapter, we will introduce the implementation of our demo game and explain the basic principles and algorithms behind it.
\todo {mention measurements}

After consideration of the various approaches implemented in games and also proposed efficient solutions to the problem of real-time destructible environment, we decided to implement and test a combination of reviewed techniques:  Our approach is similar to \emph{Geomod} (described in \cref{sec:common}) and \emph{Real Time Dynamic Fracture with Volumetric Approximate Convex Decompositions}(RTDF) (described in \cref{sec:RTDF}), but with several key differences described below.

\section{Main algorithm}
\todo{tohle zacina trochu odprostred --- jaky sou struktury v tom algoritmu? jak reprezentujes objekty? kde se tam objevi ta kolize?}
Our approach generates Voronoi cell at the point of collision. Then the difference of original mesh and the Voronoi cell is calculated and represents the damaged object. To generate the debris, the intersection of original mesh and the Voronoi cell is calculated. This action effectively cuts the object into two or more pieces, all of which are put back into simulation and can be damaged again (see \cref{fig:subtraction}). The Voronoi cell was chosen because it has easily randomizable shape and provides aesthetically good results. This choice is in no way critical to the rest of algorithm, any other closed mesh can be used as well.

Similarly to the RTDF approach, the cost of fracturing in our implementation is solely dependent on the size and complexity of the fractured object. \todo{odkaz na merania} This makes the method suitable for use in computer games and real-time simulations. \todo{to je trosku bold claim --- urcite to nebude fungovat pro vsechny hry. Je dobry se presne vymezit --- velikost objektu do cca X polygonu, ...}

\begin{figure}
        \centering
        \includegraphics[width=\textwidth]{img/subtractionProcess}
        \caption{object with point of impact (left), generated Voronoi cell (centre), object divided into six new smaller objects after subtraction of Voronoi cell (right)}
        \label{fig:subtraction}
\end{figure}

Randomization of the size and shape of a Voronoi cell guarantees different result after every collision. The generation of a Voronoi cell takes place in a closed domain with its centre at the point of collision. In the domain, in addition to the centre point, random points need to be generated. The used Voronoi cell is the cell of the centre point cut by the boundaries of the domain if necessary.
\todo{Tadyto vysvetleni neni OK, predpoklada ze clovek uz vi jak ten tvuj algoritmus funguje a tady ho jen tak ujistujes ze to dobre chape. }

We also considered implementation based on \emph{A fast method for simulating destruction and the generated dust and debris} (see \cref{sec:edem}). To test this approach, we set up a cube divided into 439 tetrahedrons.\todo{Tohle je mereni, do designu to definitivne nepatri. Muzes sem napsat ze si svou metodu vybral experimentalne ze dvou protoze ta druha mela degraded performance, a odkazat se na mereni.} After introducing constraints to hold the tetrahedrons together, we experienced a drop from 60fps (set as an upper limit) to 13fps. Having a large number of elements connected with springs in the simulation can also trigger an undesirable behaviour, such as contractions, retractions and self-induced explosions of the object. Performance issues and problems with keeping elements in a stable state finally concluded that the approach was not suitable for our implementation.


\section{Program Structure}
Disregarding the initialization\todo{mozna rekni ze ji popises pozdejs a dej duvod proc to odkladas, neni moc dobry to zbytecne roztrhat.}, the program runs in following steps:
\begin{enumerate}
\item Perform a step in physics simulation.
\item Handle collisions and perform destruction, see \cref{sec:collisions}.
\item Read user input and then apply correct forces to controlled vehicle.
\item Render current state of objects. In this step, a graphical representation of every object is updated to comply with its rigid body version.
\end{enumerate}

\begin{figure}
        \centering
        \includegraphics[width=\textwidth]{img/decompositionFlow}
        \caption{Diagram is showing multiple threads handling collision event. }
        \label{fig:threads}
\end{figure}
To make the simulation faster, we can \todo{We can execute...but did we? `Can' se idealne vyhni vsude kde neni uplne nutny, bud tam ty vlakna mas (a napis to tam rovnou), nebo nemas (a napis to bokem jako moznej dalsi improvement, ne do popisu svyho algoritmu)} execute the most costly tasks asynchronously in separate threads. These tasks are convex decomposition and mesh subtraction. As a result, the program is running in three threads (\cref{fig:threads}): the main thread, a thread for subtracting meshes and a thread for decomposing triangular mesh into a set of convex shapes (\cref{sec:decomposition}). Both subtraction and decomposition threads communicate solely with the main thread, and all communication is done in producer-consumer model. Figure \ref{fig:objectInThreads} shows the changes of the object and its collision shape across all threads.
\todo{Oponenta okamzite napadne, jestli by nebylo lepsi na to nahodit nejakej worker pattern a mit tech threadu potencialne nekonecno. Bylo by dobry bud potvrdit ze to mozny je, nebo rict proc si to neimplementoval.}

\begin{figure}
        \centering
        \includegraphics[width=\textwidth]{img/object-progress}
        \caption{Simplified overview of changing states of a single object across multiple threads in simultaneous time slots. We can see the process of splitting the mesh and calculation of collision shapes from the time of the collision until the convex decomposition is calculated for all parts. Blue lines represent the collision shape, black lines represents the visual mesh (not shown if it is the same as the collision shape), red dot represents the collision point.}
        \label{fig:objectInThreads}
\end{figure}

\section{Collision handling}
\label{sec:collisions}
\todo{odkud se vemou ty reference?}
After the collision, we get a reference to two rigid bodies participating in the collision, point of collision and vector of force from the physics engine. For simplification, we will consider only one object, the point of impact and the force.

At first, we need to filter out unwanted collisions (collisions that should not damage the object). Those collisions can be results of an object placed on ground or collisions with not enough force to damage the object. 

For every valid\todo{`valid' znamena `not unwanted' z predchoziho odstavce?} collision, we generate Voronoi cell as described before, and put \todo{move?} meshes of both objects into a task for mesh subtraction thread. After enqueuing all collisions, we can check if there are any prepared subtraction results for further use. The result of one subtraction task is a set of meshes that represent new objects. For every mesh, we create a new object, but we do not have its convex decomposition for the physics engine to perform accurate collision detection. Because the decomposition can take relatively long, we create a simple temporary collision shape (\eg sphere) and a task for decomposition\todo{of the sphere?}. Then we proceed with simulation, not waiting for the result. Decomposition is done in a separate thread, and the result is returned to the main thread where we check for decomposed shapes. With the shape ready in the main thread we replace the temporary shape for compound shape consisting of convex parts.

This process guarantees that we do not wait for either subtraction or decomposition and therefore we can have stable fps in our game. Temporarily replacing a collision shape by a simpler alternative ensures consistent behaviour of new objects (we can put them into the simulation, and they do not fall through each other or otherwise not comply with laws of physics)\todo{prvni veta je OK, ale druha uz neni uplne pravda --- kdyz strelis do krychle a chvilku ji nahradis kouli, okoli muze slusne explodovat... To by chtelo bud dovysvetlit presnejc, nebo rict ze ty temporary collision shapes jsou dostatecne podobny (a jak jsi toho docilil). Nasledujici veta by nemela zacinat `Therefore' --- spis neco jako ze nedostatecnej vykon pri pocitani meshu kterej by se jinak podepsal na vykyvech ve FPS jsi nahradil tim ze u slozitejch akci trva dyl nez se projevej.}. Therefore we need to calculate the difference of meshes in a period of a few frames so it can not be seen that it is lagging behind collisions.

\section{Convex Decomposition}
\label{sec:decomposition}
Regardless of used physics engine \todo{nekde us je zminenej physics engine?}, our objects are represented as triangular meshes. It means \todo{it means that they are made from triangles. Navic i na triangle meshich jde delat presny kolize, akorat to je neprakticky pro rychly kontrolovani.} that to perform accurate mesh to mesh collisions, every object needs to have its collision shape in the form of compound shape consisting of convex bodies. While it is desirable to have a decomposition into a minimum number of pieces, this problem is known to be NP-hard \cite{convexDecomp}. \todo{jak to NP-H souvisi s kolizema? Obecne moc neni videt co se timhle odstavcem chtelo presne rict.}

In the setting of a computer game, the speed of calculation is much more relevant than the precision --- small differences between collision shapes and visual meshes are not considered to be a problem. To be able to perform collisions\todo{collision calculations? fragmentations? or just detections?} at real-time, a number of approximate convex decomposition algorithms that sacrifice some precision to gain performance have been proposed. \todo{citation needed}

We have chosen to use \emph{Hierarchical Approximate Convex Decomposition} algorithm (see \cref{sec:decompositionLib}). The application is designed in such way that after every mesh subtraction convex decomposition is applied to the rest of the original mesh and each new object.

\section{Measurements???}
\todo{nieco rozumne namerat a napisat o tom}

(Napady na mereni, muzes si do programu dodelat hooky ktery ti jen vysypou statistiku a timingy u tech operaci:
\begin{itemize}
\item Kolik prumerne trva prevedeni triangle meshe na HACD --- treba graf co porovnava jakej vliv ma pocet trojuhelniku/konvexnost/konkavnost na dylku vypoctu).
\item Kolik prumerne trva jedno spocitani detekce kolizi v zavislosti na poctu a velikosti objektu?
\item Kolik casu sezere vlakno co dela ten subtraction (zase v zavislosti na tom jak velkej objekt se resi)?
\item Kolik casu sezere vlakno co dela tu dekompozici?
\end{itemize})

